"use strict";

const fs_extra_p_1 = require("fs-extra-p");
const util_1 = require("../util");
const path = require("path");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../awaiter");
// we use relative path to avoid canonical path issue - e.g. /tmp vs /private/tmp
function copyFiltered(src, destination, filter) {
    let dereference = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    return fs_extra_p_1.copy(src, destination, {
        dereference: dereference,
        filter: filter
    });
}
exports.copyFiltered = copyFiltered;
function createFilter(src, patterns, ignoreFiles, rawFilter) {
    return function filter(it) {
        if (src === it) {
            return true;
        }
        if (rawFilter != null && !rawFilter(it)) {
            return false;
        }
        let relative = it.substring(src.length + 1);
        // yes, check before path sep normalization
        if (ignoreFiles != null && ignoreFiles.has(relative)) {
            return false;
        }
        if (path.sep === "\\") {
            relative = relative.replace(/\\/g, "/");
        }
        return minimatchAll(relative, patterns);
    };
}
exports.createFilter = createFilter;
function listDependencies(appDir, production) {
    return __awaiter(this, void 0, void 0, function* () {
        let npmExecPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
        const npmExecArgs = ["ls", production ? "--production" : "--dev", "--parseable"];
        if (npmExecPath == null) {
            npmExecPath = process.platform === "win32" ? "npm.cmd" : "npm";
        } else {
            npmExecArgs.unshift(npmExecPath);
            npmExecPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
        }
        const result = (yield util_1.exec(npmExecPath, npmExecArgs, {
            cwd: appDir,
            stdio: "inherit",
            maxBuffer: 1024 * 1024
        })).trim().split("\n");
        if (result.length > 0 && !(result[0].indexOf("/node_modules/") !== -1)) {
            // first line is a project dir
            const lastIndex = result.length - 1;
            result[0] = result[lastIndex];
            result.length = result.length - 1;
        }
        return result;
    });
}
exports.listDependencies = listDependencies;
// https://github.com/joshwnj/minimatch-all/blob/master/index.js
function minimatchAll(path, patterns) {
    let match = false;
    for (let pattern of patterns) {
        // If we've got a match, only re-test for exclusions.
        // if we don't have a match, only re-test for inclusions.
        if (match !== pattern.negate) {
            continue;
        }
        // partial match — pattern: foo/bar.txt path: foo — we must allow foo
        // use it only for non-negate patterns: const m = new Minimatch("!node_modules/@(electron-download|electron-prebuilt)/**/*", {dot: true }); m.match("node_modules", true) will return false, but must be true
        match = pattern.match(path, !pattern.negate);
        if (!match && !pattern.negate) {
            const rawPattern = pattern.pattern;
            // 1 - slash
            const patternLengthPlusSlash = rawPattern.length + 1;
            if (path.length > patternLengthPlusSlash) {
                // foo: include all directory content
                match = path[rawPattern.length] === "/" && path.startsWith(rawPattern);
            }
        }
    }
    return match;
}
//# sourceMappingURL=filter.js.map